= Семинар 3. продолжение constexpr, макросы

== Вопросы по предыдущему семинару

???

== Разбор контрольной

=== Сложна сложна

Некоторые говорят, что контрольная была слишком сложной. И отчасти из-за моей первой задачи.

Извините, я учту это в следующих контрольных. В своё оправдание - это первый раз, когда я делал задачи для контрольной работы.

=== Вспомним задачу 1

Дан вектор строк `workers`, вектор пар <строка, число> `workers_info` и число `n`.

Необходимо сопоставить каждую строку из `workers` с числом из `workers_info`.

Затем взять первые `n` работников по числу, удалив другие.

Отсортировать получившийся массив.

И всё это без циклов.

=== Как решать? 1.1

Для начала надо сопоставить каждому работнику числу из `workers_info`.

Чтобы найти это число быстро, можно вспомнить, что массив `workers_info`
отсортирован по строкам и там можно использовать двоичный поиск (`std::lower_bound`).

Чтобы сопоставить каждому работнику число, мы по сути должны отобразить каждую строку из `workers`
во что-то типа пары <строка, число>. Такого рода преобразования в хаскеле и джаве называется `map`,
у нас же это называется `std::transform`. Внутри каждого `transform`-а нужно было с помощью `std::lower_bound`
найти нужное число и вернуть пару <строка, число>.

Увидев, что не всегда есть по строке число, можно пойти двумя пути:

1. всё равно выставлять пару, с каким-нибудь очень маленьким числом, и в конце отфильтровать из ответа это число
2. работать с опциональными парами std::optional<строка, число>.

Я решал вторым способом.

Получили такое преобразование

```
std::vector<std::pair<std::string, int>>
GetTopWorkers(const std::vector<std::string> &workers,
              const std::vector<WorkerInfo> &workers_info,
              size_t n) {
  std::vector<std::optional<std::pair<std::string, int>>> worker_and_sp;
  std::transform(
      workers.begin(), workers.end(), std::back_inserter(worker_and_sp),
      [&workers_info](const std::string &worker)
          -> std::optional<std::pair<std::string, int>> {
        const auto found = std::lower_bound(
            workers_info.begin(), workers_info.end(), worker,
            [](const WorkerInfo &sp_record, const auto &wrk) {
              return sp_record.name < wrk;
            });
        if (found == workers_info.end() || found->name != worker) {
          return std::nullopt;
        }
        return std::pair(worker, found->story_points);
      });
```

=== 1.2

Теперь надо отфильтровать nullopt-ы. Проще простого

```
  std::vector<std::pair<std::string, int>> filtered;
  std::transform(
      worker_and_sp.begin(),
      std::remove_if(worker_and_sp.begin(), worker_and_sp.end(),
                     [](const auto &opt) { return !opt.has_value(); }),
      std::back_inserter(filtered), [](const auto &opt) { return *opt; });
```

Для этого используем функцию `remove_if`, которая переносит все объекты, удовлетворяющие предикату,
"направо" и возвращает итератор на начало этого "права". Дальше преобразовываем эти опциональные пары
в просто пары и получаем неотсортированные смаппленые значения.

Можно было заюзать модный и молодёжный `erase_if`, чтобы чуть более красиво было

=== 1.3

Дальше, признаюсь честно, я сам написал решение, не соответствующее асимптотике.
Я просто отсортировал полученный список и взял первые n элементов.
И получил таким образом асимптотику `O(|workers| log(max(|workers_info|, |workers|)))`

Чтобы решить за честный `O(|workers| log(|workers_info|))`, надо было использовать
`nth_element`. Эта функция находит n-ю порядковую статистику, и ставит её на n-е место.

Решение выглядит примерно так (взял решение andysilv, спасибо):

```
  n = std::min(n, filtered.size());
  auto cmp = [](auto& a, auto& b){ return a.second > b.second; };
  std::nth_element(filtered.begin(), filtered.begin() + n, filtered.end(), cmp);
  filtered.resize(n);
  std::sort(filtered.begin(), filtered.end(), cmp);
  return filtered;
```


=== Вспомним задачу 2

Даны два итератора, функция, которая мёржит соседние элементы, если они равны, и OutputIterator.

Нужно таким образом смёржить данный нам интервал

=== Решение

Можно было решить разными способами, задачка похожа на какую-нибудь из задачек с литкода про два указателя.

Храним начало "равного отрезка". Пока начало и текущий элемент равны - продолжаем двигать указатель на текущий элемент.

Нашли "неравный" - мёржим весь отрезок с помощью `accumulate` и сдвигаем указатели.

А можно было нагуглить решение

https://www.fluentcpp.com/2019/10/15/merge-consecutive-elements-cpp-collection/

=== Вспомним задачу 3

Дан список задач. Задача описывается

1. Проектом
2. Исполнителем
3. Потраченным временм

Требуется вернуть массив структур с вектором работников по этому проекту.
При этом вектор работников должен быть отсортирован по убыванию затраченного времени.

=== Решение

Отсортируем список задач по проекту, если проекты равны - по сотруднику.

```
  std::sort(tasks.begin(), tasks.end(), [](const auto &x, const auto &y) {
    if (x.project == y.project) {
      return x.assignee < y.assignee;
    }
    return x.project < y.project;
  });
```

Этот список можно превратить в список структур `ProjectResult`, которые мы должны получить.
Только по каждой задаче будет будет отдельная запись, а нам их надо смёржить.

```
  using Result = std::vector<ProjectResult>;
  Result t;
  std::transform(tasks.begin(), tasks.end(), std::back_inserter(t),
                 [](const Task &task) -> ProjectResult {
                   return {task.project, {{task.assignee, task.spent_sp}}};
                 });
```

Теперь можем применить функцию CollapseSequential. Будем считать проекты равными,
если их имена равны. А объединять так: если текущая запись о том же сотруднике, что и последняя
записанная - добавляем количество сторипоинтов к предыдущей записи. Иначе - создаём новый объект в массиве `ProjectResult.worker_results`.

```
  Result not_sorted;
  CollapseSequential(
      t.begin(), t.end(), std::back_inserter(not_sorted),
      [](const ProjectResult &r1, const ProjectResult &r2) {
        return r1.project_name == r2.project_name;
      },
      [](const ProjectResult &r1, const ProjectResult &r2) -> ProjectResult {
        std::vector<WorkerResult> w1{std::move(r1.workers_results)};
        if (r1.workers_results.back().worker_name
            == r2.workers_results.front().worker_name) {
          w1.back().story_points +=
              r2.workers_results.front().story_points;
        } else {
          w1.push_back(r2.workers_results.front());
        }
        return {r1.project_name, std::move(w1)};
      });
```

Внимательный читатель обратит внимание, что я тут копирую вектора налево и направо. Решается move_iterator-ом и аккуратными move-ами.

И в конце остаётся отсортировать полученные списки по каждому проекту.

```
  Result result;
  std::transform(
      not_sorted.begin(), not_sorted.end(), std::back_inserter(result),
      [](ProjectResult kv) {
        std::sort(kv.workers_results.rbegin(), kv.workers_results.rend(),
                  [](const WorkerResult &w1, const WorkerResult &w2) {
                    return w1.story_points < w2.story_points;
                  });
        return kv;
      });
  return result;
```

== Домашка

== Задача 1 (2.5 балла): сериализация объектов

=== Базовая часть (1.5 балла)

Познакомимся (а может кто-то уже знаком) с сериализацией буста.

https://www.boost.org/doc/libs/1_75_0/libs/serialization/doc/index.html

Вам даны простенькие структуры данных: точка, линия, объект с атрибутами.

От вас требуется научиться их (де)сериализовать с помощью boost serialization.

=== Тесты (1 балл)

Напишите тесты на полученную (де)сериализацию.

== Задача 2(1 балл): балуемся с библиотеками

Задача простая.

1. Создайте статическую библиотеку с функцией суммирования sum (тип -- `int (int, int)`)
2. Создайте динамическую библиотеку с функцией произведения mul (тип -- `int (int, int)`)
3. Напишите тест на sum
4. Напишите тест на mul. Библиотека с функцией mul должна загружаться *в коде*,
при компиляции (линковке) исполняемого файла эту библиотеку указывать нельзя.
5. Вместе с исходниками положите в репозиторий Makefile или скрипт для сборки и запуска теста.
Скрипт должен выполниться и тесты должны пройти на неподготовленном компьютере преподавателей.
На компьютере преподавателей конечно же есть стандартные пакеты, в скрипте не надо устанавливать
компиляторы и прочее.

== Библиотеки

== Ещё раз, зачем это всё?

== Моя первая библиотека

Напишем библиотеку для работы с файловой системой

== Хотим динамическую библиотеку

И напишем. Реализуем утилиту du.

fPIC

ldd

== Пример большой либы

Посмотрим на размер объектного файла в зависимости от типа либы

== plt и got

Почитайте на досуге, если интересно. В ассемблере можно увидеть вызов методов через plt

== Где хранится динамическая библиотека

Хранится в памяти ядра. При загрузке, память, относящаяся к динамической библиотеке
мапится в память процесса.  Память маппится в режиме cow, так что изменение
глобальных данных в либе приводит к изменению этих данных только в этом процессе.

== Модификаторы доступа

Из библиотеки можно выборочно экспортировать символы.

Чтобы люди не путались - в винде противоположно относительно линукса.

В винде по умолчанию ничего не экспортируется, в линуксе по умолчанию всё экспортируется.

У gcc есть специальный макрос, у clang наверно тоже

https://gcc.gnu.org/wiki/Visibility

== Плохая библиотека

Попробуем сломать код, компилируя библиотеку и приложение с разными флагами.

Напомню, так делать нельзя -- флаги должны совпадать при компиляции приложения с флагами библиотеки.

== Ссылки на почитать

Про plt, got и fPIC https://unix.stackexchange.com/questions/116327/loading-of-shared-libraries-and-ram-usage

Про динамические либы сложно, но есть полезное: https://amir.rachum.com/blog/2016/09/17/shared-libraries/

Про elf более-менее понятно https://linux-audit.com/elf-binaries-on-linux-understanding-and-analysis/

И тоже про plt+got https://stackoverflow.com/questions/5469274/what-does-plt-mean-here