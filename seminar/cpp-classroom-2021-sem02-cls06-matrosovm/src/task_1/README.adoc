== Задача 1.1. Распараллеливание

В стандарте существуют распараллеленные версии алгоритмов, такие как

[source,cpp]
template<
    class ExecutionPolicy,  // std::execution::{sequential/unsequential}
    class It,
    class Fun
>
void std::for_each(ExecutionPolicy policy,
    It first, It last,
    Fun fun
);

Однако, поддерживать их или нет - отдано на откуп компиляторам.

*Напишите рукодельную версию алгоритма*, со следующей сигнатурой

[source,cpp]
template<class ForwardIt, class Fun>
void parallel_for(
    size_t num_threads,  // строго больше 0
    ForwardIt first, ForwardIt last,
    Fun fun
);

обладающую следующими свойствами:

- однократно вызывает fun для каждого элемента набора, порядок вызовов (из-за многопоточности) не специфицирован
- поддерживает итераторы ForwardIterator (а не только RandomAccessIterator)
- разбивает набор на num_threads частей примерно равной длины (то есть, например, 10 / 4 = {3, 3, 2, 2}, а не {3, 3, 3, 1} или {2, 2, 2, 4})
- выполняет обработку в num_threads потоков, включая текущий (в частности, при num_threads=1 вырождается в std::for_each)
- дожидается завершения всех задач

Обработка исключений не предполагается.

== Задача 1.2. Добавьте обработку исключений

Для того, чтобы пробросить исключение из одного (рабочего) потока в другой (основной), нужно это исключение поймать, сохранить в некоторую общую для обоих потоков переменную, а затем в другом потоке бросить заново.

[source,cpp]
----
std::exception_ptr eptr;  // shared_ptr-подобный контейнер исключения

void worker_thread_body() {
    try { .... }
    catch(...) {
        eptr = std::current_exception();
        // не бросаем дальше!
    }
}

.....
worker_thread.join();
if (eptr) {
    std::rethrow_exception(eptr);
}
.....
----

Разумеется, если запущено несколько рабочих потоков, то более-менее одновременно могут быть брошены несколько разных исключений. Что ж, в этом случае нужно пробросить любое из них.

Поддержите исключения в функции `parallel_for()`:

- Как только в рабочем потоке возникло исключение, он прекращает обработку оставшихся у него элементов поднабора
- Как только любой поток обнаруживает, что было брошено исключение, он тоже прекращает обработку
- Переменная - контейнер исключений - общая только для текущего и рабочих потоков алгоритма, не делайте её глобальной! Представьте, что одновременно в разных потоках запущены разные `parallel_for()` - они не должны влиять друг на друга.

Важный момент: *избегайте гонки* при чтении/записи в контейнер исключений.

Для этого

- или прибегните к защите одной общей переменной мьютексом,
- или напишите lock-free код, гарантирующий, что переменная будет записана единожды
- или заведите массив переменных "исключение из данного потока" и разбирайтесь с ними (но это, имхо, некрасиво и неэффективно)
