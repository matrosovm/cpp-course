== Задача 3. Условные переменные и мониторы

Как показал Дейкстра, на семафорах можно построить любую синхронизацию потоков. Как показал Хоар, на мониторах можно построить семафоры :)

Давайте напишем небольшую библиотеку средств синхронизации, _по мотивам_ того, что вошло в Стандарт C++20, но ещё не доехало до релизных версих компиляторов.

=== 3.1. Семафор

Это счётчик, который нельзя декрементировать ниже нуля.

[source,cpp]
class Semaphore {
public:
    explicit Semaphore(unsigned value);  // стартовое значение
    void acquire();  // декремент с ожиданием
    void release();  // инкремент (мгновенный)
    bool try_acquire();  // декремент или отказ
};

=== 3.2. Read-Write Lock

Довольно востребованный механизм синхронизации, позволяющий нескольким потокам одновременно войти в защищённую секцию, при условии, что они не будут изменять данные (доступ на чтение).

Доступ на запись - строго монопольный.

[source,cpp]
----
class RWLock {
public:
    void lock_read();
    void unlock_read();
    void lock_write();
    void unlock_write();
};
----

Обратите внимание, что возможно голодание: читатели приходят и уходят, а писатель стоит в ожидании, когда же они все уйдут, наконец!

== 3.3. Канал ограниченного размера

Зачастую, семафор отражает "физическую сущность": количество данных, отправленных потребителю поставщиком. Когда потребитель пытается взять очередной элемент из очереди, он декрементирует семафор (или ждёт, пока в очереди что-нибудь появится). Поставщик, после того, как добавил элемент, инкрементирует семафор.

С другой стороны, места в очереди тоже не бесконечны, поэтому можно представить, что от потребителя к поставщику есть очередь дырок. И это - ещё один семафор.

Плюс, не надо забывать, что процедуры взять-вынуть должны быть защищёнными. Соответственно, нужны или lock-free структуры, или мьютекс (третий семафор!).

Причём все три семафора работают не сами по себе, а взаимосвязаны: количество элементов противоположно количеству дырок.

Поэтому логичное решение - отказаться от россыпи семафоров и сделать один монитор, который управляет очередью.

Напишите шаблон контейнера "синхронизированная очередь"

[source,cpp]
template<class T>
class Queue {
public:
    explicit Queue(size_t limit);
    size_t size() const;
    size_t free_size() const;
    void push(const T&);  // ждёт свободное место!
    T pop();  // ждёт данные!
};
