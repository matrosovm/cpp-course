== Задача 2. Взаимоисключительный доступ (мьютексы)

Давайте рассмотрим разновидность типичной задачи производитель-потребитель.

Пусть у нас есть некоторый буфер, задача которого - собирать пачки данных от внешних источников, и залпом отдавать приёмнику.

[source,cpp]
----
template<class T>
class Buffer {
public:
    using Pack = std::vector<T>;
    using Callback = std::function<void(const Pack&)>;

    Buffer(size_t limit, Callback callback):
            limit_(limit),
            callback_(callback) {}

    void push(const T& v) {
        pack_.push_back(v);
        if (pack_.size() == limit_) {
            flush();
        }
    }
    void flush() {
        callback_(pack_);
        pack_.clear();
    }
private:
    const size_t limit_;
    const Callback callback_;
    Pack pack_;
};
----

Данный буфер не защищён и ещё непригоден для работы в многопоточном окружении.

Мы хотим избавить пользователей от необходимости управлять доступом к буферу - добавим сюда блокировки.

=== 2.1. Делаем буфер многопоточным.

Защитите функции `push()` и `flush()`, чтобы их можно было безопасно вызывать из нескольких потоков.

Обратите внимание, что push() вызывает flush(), поэтому нельзя *просто так* взять `std::mutex` и блокировать его в обеих функциях. Дело в том, что обычный мьютекс - не реентерабельный.

Что можно предпринять?

- взять реентерабельный мьютекс `std::recursive_mutex`
- отрефакторить код так, что push() и flush() блокируют `std::mutex` и внутри себя безопасно вызывают неблокирующие реализации
- отрефакторить код так, что push() и flush() совместно владеют блокировщиком (`std::shared_lock` или `std::unique_lock`)

=== 2.2. Заботимся об эффективности

У нашего буфера есть несколько потенциально длительных операций:

- конструкторы и деструктор элемента
- пользовательский колбек

Можем ли мы уменьшить время пребывания в заблокированном состоянии, чтобы не заставлять другие потоки ждать?

Какие требования мы при этом выдвигаем к длительным операциям?

- Будем считать, что колбек реентерабельный
