= Многопоточное программирование

== Основные проблемы

- распараллеливание
- транзакционность
- синхронизация

== Распараллеливание

=== Потоки

Запускаем потоки, оборачивая их в std::thread

[source,cpp]
std::thread t([&]() {
    .....
});
.....
t.join();

У потоков есть семантика перемещения:

[source,cpp]
std::thread t;
assert(!t.joinable());  // ещё не создан
t = std::thread(func, args);  // создали
assert(t.joinable());
t.join();

Если нужно дождаться завершения нескольких потоков, просто последовательно вызываем join у каждого из них.

=== Фьючерсы

Высокоуровневый, абстрактный механизм распараллеливания.

(В этот раз мы их не будем разбирать, тема слишком обширная)

[source,cpp]
std::future<Result> f = std::async(std::launch::async, fun, args);
// f.wait();
auto v = f.get();

== Транзакционность

Даже при чтении-записи элементарных типов данных могут происходить нежелательные взаимодействия (или не происходить желательные) между потоками.

На элементарном уровне это решается с помощью атомарных типов и операций над ними: `std::atomic<T>`.

Доступ к атомарным типам - неблокирующий (lock-free). Это достоинство, которое нивелируется тем, что атомарные типы - примитивные.

Для работы со сложными структурами данных удобно переключаться как бы в однопоточный режим: заблокировали от посторонних влияний, сделали всё, что хотели (полностью предсказуемо для себя), оставили данные в непротиворечивом состоянии, разблокировали.

Это обеспечивается критическими секциями (мьютексами) и мониторами.

== Синхронизация

Потоки не просто работают независимо друг от друга, хоть и над общими данными, но и обмениваются между собой.

Для этого приходится дожидаться друг друга.

Хорошо, когда задачу можно представить в виде "сделать всё и дождаться завершения", тогда это сведётся к thread::join() или future::wait().

В противном случае нужны способы управляемого ожидания состояний/событий/условий.

Самое простое - это условие "разделяемые данные свободны", это мьютекс.

Более сложные - например, построение конвееров производитель-потребитель.

Ожидание произвольных условий - это или активный опрос
[source,cpp]
while(!ready()) sleep();

или подписка на какой-нибудь триггер (на те же фьючерсы)
[source,cpp]
event.wait();

== Задачи

Описание задач лежит в README.adoc файлах в подкаталогах

- file://./src/task_1/README.adoc[Задача 1] Распараллеливание
- file://./src/task_2/README.adoc[Задача 2] Мьютексы:
- file://./src/task_3/README.adoc[Задача 3] Синхронизация: Условные переменные и мониторы
