= Семинар I
:icons: font
:table-caption!:
:cls01ple-caption!:
:source-highlighter: highlightjs
:revealjs_hash: true
:customcss: https://gistcdn.githack.com/fedochet/4ee0f4a2224ecd29a961082a0c63c020/raw/18c107982aba90bb94194c0ac3a8a5ca9bad6782/asciidoc_revealjs_custom_style.css
:revealjs_theme: blood
:stylesheet: main.css

== Вступление

* В каком формате будут проходить семинары?
- Решение задачек на паре: за решение у доски будут вознаграждения
- Дорешивание дома с последующей проверкой (aka "дорешки")
- Раз в четыре занятия - контрольная

* Обязательства
- обязательно сдавать дорешки и котрольные, посещать можно не всегда

== Задачки

Вся функциональность должна быть реализована в пространстве имён cls01. Детали реализации, не являющиеся интерфейсами, следует выносить во вложенное пространство имён `detail`.

== Задачка 1: разбиение строки [1 балл]

**[0.5 балла]** Реализуйте функцию, которая разбивает переданный на вход текст используя объект-разделитель.
Объект-разделитель имеет шаблонный тип, от которого требуется наличие метода `find` для поиска чего-то в строке начиная с определённой позиции.

[source,cpp]
----
// Delimiter - любой класс имеющий в интерфейсе метод
// std::string_view find(std::string_view text, size_t pos)
// Возвращает string_view на найденный разделитель
// (поиск идёт начиная с позиции pos)

template<class Delimiter>
std::vector<std::string_view> split(std::string_view text, Delimiter d);
----

ifdef::backend-revealjs[=== !]

Поддержите две реализации класса `Delimiter`:

1. `StringDelimiter` - ищущую вхождение строки (строка-шаблон задаётся в конструкторе)
2. `RegexDelimiter` - ищущую вхождение регулярного выражения (регулярное выражение задаётся в конструкторе)

ifdef::backend-revealjs[=== !]

**[0.5 балла]** Теперь хотим найти самые длинные предложения в тексте. Результат следует возвращать в векторе `std::string_view`

Если более одного предложения имеет максимальную длину, их следует вернуть в порядке появления предложений в тексте.
Разделитель предложений передаётся отдельным аргументом, по умолчанию предложения отделены друг от друга точкой с пробелом.
Разделитель предложений не участвует в вычислении длины предложения.

NB Используйте в реализации `std::multimap`.

[source,cpp]
----
template<class Delimiter>
std::vector<std::string_view> get_longest_sentences(std::string_view text, Delimiter d);

// Пример использования
std::string some_text = "This. Is. Long.";
std::vector<std::string_view> longest_sentences = get_longest_sentences(some_text);
// Должны получить ["This", "Long"]
----


== Задачка 2: перестановки [1 балл]

*[0.5 балла]* Требуется реализовать функцию, позволяющую получить все уникальные перестановки элементов. Для удобства в `std` уже есть функция `std::next_permutation`, вероятно её имеет смысл использовать.

ifdef::backend-revealjs[=== !]

В последующем сниппете мы встретимся с возможно новым синтаксисом **шаблонных шаблонных**
(eng. template template) параметров.

[source,cpp]
----
template<class BidirIt,
         template<typename> class OutContainer = std::vector,
         template<typename> class OutContainersContainer = std::vector>
OutContainersContainer<OutContainer<typename BidirIt::value_type>>
get_all_unique_permutations(BidirIt first, BidirIt last);

// пример
std::vector<int> numbers = {1, 2, 3};
std::vector<std::vector<int>> permutations = get_all_unique_permutations(
  numbers.begin(), number.end());
----

ifdef::backend-revealjs[=== !]

*[0.5 балла]* Реализуйте функцию get_all_permutations, которая возвращает все перестановки элементов, не игнорируя повторяющиеся.

[source,cpp]
----
// пример
std::vector<int> numbers = {1, 1, 1};
std::vector<std::vector<int>> permutations = get_all_permutations(
  numbers.begin(), number.end());
// permutations == {{1,1,1}, {1,1,1}, ..., {1,1,1}}
//                 \_________ 6 элементов ________/
----



== Задачка 3: маскирующийся shared_ptr [0.5 балла]

Иногда надо уметь по одному `std::shared_ptr` уметь строить другой, который будет жить ровно столько же,
сколько и первый.

ifdef::backend-revealjs[=== !]

Пример

* Представим, что мы имеем `shared_ptr` объекта
* Допустим, хотим завести `shared_ptr` на его поле.
* Хотим, чтобы родительский `shared_ptr` не убивал объект, пока где-то есть хотя бы один из живых `shared_ptr` (на объект / на поле)
* Не хотим, чтобы shared_ptr на поле чистил поле при освобождении (ведь для этого есть деструктор объекта!)

ifdef::backend-revealjs[=== !]

Подсказка: внимательно просмотрите все варианты конструкторов `std::shared_ptr`, среди них
есть подходящий нам.

[source,cpp]
----

template<class ObjectType, class FieldType>
std::shared_ptr<FieldType> field_restricted_shared_ptr(
  std::shared_ptr<ObjectType>& obj,
  std::function<FieldType*(ObjectType& obj)>);

----


== Задачка 4: сколько работает функция? [0.5 балл]

Реализуйте функцию `measure_exec_time`, возвращающую время (в дабловых миллисекундах), затраченное на вызов переданной функции с переданными аргументам

Пример:

[source,cpp]
----
std::cout << measure_time(sin, 3.1415926) << std::endl;
----

NB функция может иметь сколько угодно аргументов
NBB есть такой зверь как perfect forwarding

== Задачка 5: zip
Разработайте шаблонный класс `zip`, позволяющий итерироваться по набору нескольких контейнеров одновременно.


=== Базовая часть [1 балл]

В базовой части мы ограничиваемся двумя контейнерами в конструкторе `zip`, а также не требуем возможности итерироваться в обратном порядке и уметь работать с констаными контейнерами. Можно выдохнуть, пока нет variadic templates :) Тем не менее, `zip` шаблонен (по типам контейнеров от которых он создается).

ifdef::backend-revealjs[=== !]
Должны быть определены типы

* `zip::iterator`
* `zip::const_iterator`

ifdef::backend-revealjs[=== !]
`zip::[const_]iterator` должен поддерживать

* разыменование (`operator*`)
* `operator++` (pre/post)
* `operator==`, `operator!=`
* `operator->`

ifdef::backend-revealjs[=== !]
Разыменованный итератор возвращает ссылку (или константную ссылку) на `ZipTuple` - наследник `std::tuple` (не пару!), содержащий соответствующие элементы из всех контейнеров,
имеющий дополнительный метод get<size_t N> для доступа к N-му элементу кортежа.

ifdef::backend-revealjs[=== !]
Необходимые методы `zip`

* конструкторы: от двух контейнеров, копирования
* operator=
* `begin`, `end` (const / non-const)
* `cbegin`, `cend`

ifdef::backend-revealjs[=== !]
Также реализуйте вспомогательную функцию `cls01::make_zip` (нужна для использования прежде всего в С++ до 17 стандарта когда не было CTAD),
принимающую на вход два контейнера и возвращающую сконструкированный от них `zip`.

=== Пример использования

[source,cpp]
----
std::vector<size_t> x{1,2,3};
std::string str = "hello";

// выведет
// 1; h
// 2; e
// 3; l
for (auto& pair : cls01::zip(x, str)) {
  std::cout << pair.get<0>() << "; " << pair.get<0>() << std::endl;
}
----

ifdef::backend-revealjs[=== !]

Как видим по предыдущемы примеру, переданные `zip` контейнеры могут быть разной длины. В таком случае, итерирование по `zip` должно останавливаться как только будет исчерпан контейнер с наименьшим числом элементов.

ifdef::backend-revealjs[=== !]

Замечание: объект `zip` не должен получать контейнеры во владение. Ответственностью пользователя будет обеспечение правильного
времени жизни контейнеров таким образом, чтобы `zip` имел валидные данные для итерирования, а также сохранение валидного состояния итераторов при итерировании с помощью zip.


=== Поддержка произвольного числа контейнеров [0.5 балла]

Ну тут всё понятно - хотим иметь возможность зиповать сколько угодно контейнеров. также расширьте `make_zip`.

=== Поддержка константных контейнеров [0.5 балла]

Поддержите возможность передачи констаных контейнеров в `zip`.

=== Поддержка итерирования назад [0.5 балла]

При условии, что все контейнеры поддерживают двунаправленное итерирование, хотим поддержать

* operator-- (pre/post) у итераторов,

а также завести новый класс `zip::reverse_iterator`, который будет позволять итерироваться в обратном порядке.


=== Указания

* Рекомендуется в базовой части отнаследоваться от `std::iterator<std::forward_iterator_tag, ...>`
* Для того, чтобы значения, на которые указывает итератор, можно было менять, следует хранить в итераторе либо указатели, либо объекты типа std::reference_wrapper или что-то аналогичное