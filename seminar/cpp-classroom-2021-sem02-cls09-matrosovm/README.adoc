= Семинар 9. ranges

== Домашка

== Задача 1 (1 балл): Пифагоровы штаны

Напишите функцию, которая возвращает **бесконечный** ренж с пифагоровыми тройками.
Напомню, это такие тройки x y z:  x * x + y * y == z * z.

Условия:

* Запрещается использовать генераторы и `co_yield`. За использование генераторов -3 балла.
* Запрещается пользоваться циклами, if-ами, for_each.

Есть минимум два пути решения

1. Возвращать честный ренж троек. Если на полуджаве, то `Stream<std::tuple<int, int, int>>`. У меня не получилось
сделать так из-за проблем с вложенными `std::ranges::views::join`.

2. Возвращать ренж ренжей (`Stream<Stream<std::tuple<int, int, int>>>`). i-ый ренж содержит ренж троек для `z=i`.
Третий элемент внешнего ренжа будет содержать пустой ренж.
Пятый элемент внешнего ренжа будет содержать ренж из одного элемента (5, 4, 3).

Оба варианта решений будут приниматься, если вы сделаете первым путём - надо выставить `isPythagoryanFlat` в `true`.


== Задача 2(1.5 балла): Кальянная

=== Поздача 1 (1 балл). Реализация

Миша и Ваня любят ходить в кальянную. В тот момент, когда кальянная стала их первым домом, у их друзей возник вопрос - сколько они тратят там денег. Чтобы было интереснее, стали считать не в деньгах, а в вещах. К примеру - сколько айфонов они могли купить, сколько кальянных, и проч.

Так как друзья у них занятые, им требуется помощь.

**При решении задачи нельзя пользоваться циклами, if-ами, for_each.**

Вам дано:

* список дней посещений кальянной с количеством часов, проведённых в ней
* стоимость часа
* в этой кальянной есть акция - каждый n-ый день бесплатно. Вам дано это число `happy_visit_number`. Каждый `happy_visit_number`-й день (элемент visits) учитывать не надо. Тут придётся воспользоваться мутабельным адаптером. И вроде он тут легален.
* мапа вещей, в которые нужно перевести потраченные деньги

От вас требуется посчитать, сколько денег потратили эти ребята, а затем посчитать, сколько единиц каждого предмета они могли купить на эти деньги, округлённое вниз.

Требуется вернуть два ренжа: первый - ренж вещей (`Stream<std::string>`), второй - ренж количеств соответствующих вещей (`Stream<int>`). Размеры ренжей должны совпадать. i-ый элемент первого ренжа должен соответствовать i-му элементу второго ренжа. Порядок возвращаемых "пар" не важен.

=== Подзадача 2(0.5 балла). Тесты

Допишите тесты к реализованной функции.

== Prerequisites

Я для работы с ренжами использовал g++-10.3. Можно ещё clang-13, вроде, но там "частичная поддержка". https://en.cppreference.com/w/cpp/compiler_support

== Hello, ranges

```

template <typename T>
void print(const T& t) {
  std::cout << t << ' ';
}

void hello() {
  rs::for_each(
      rs::iota_view{10, 20} | rv::filter([](const auto x) { return x % 2; }),
      print<int>);
}
```

== transform and flatten

```
void flatten() {
  auto numbers = rs::iota_view(1) | rv::transform([](const int x) {
    return rs::iota_view(1, x);
  }) | rv::take(50) | rv::join;
  rs::for_each(numbers, print<int>);
}
```

== non-const begin

Некоторые ренжи не любят const. К примеру у view, возвращенного при применении filter, метод begin неконстантный. Это сделано для кеширования этого самого begin, который будет удовлетворять предикату.

```
void non_const() {
  auto iota = rs::iota_view{0, 1000};
  std::vector<int> v(iota.begin(), iota.end());
  // const auto first_odd = v | rv::filter([](const int x) { return x % 2; }); won't complie
  auto first_odd = v | rv::filter([](const int x) { return x % 2; });
  rs::begin(first_odd);
}
```

== dangling

С ренжами надо работать аккуратно. К примеру можно получить dangling ренж. Против некоторых видов dangling ренжей защита встроена в библиотеку, против других её сделать либо накладно с точки зрения runtime, либо невозможно.

=== caught
```
void good_dangling() {
  auto get_vector = []() -> std::vector<int> {
    static std::vector v{1, 2, 3, 10};
    return v;
  };
  auto odd = get_vector() | rv::filter([](const int x) {return x % 2; });
  //  rs::for_each(odd, print<int>);
}
```

=== uncaught

```
void bad_dangling() {
  auto get_odd = [](const std::vector<int> v) {
    return v | rv::filter([](const int x) { return x % 2; });
  };
  auto iota = rs::iota_view{0, 1000};
  std::vector<int> v(iota.begin(), iota.end());
  auto first_odd = get_odd(v);
  hello();

  rs::for_each(first_odd, print<int>);
}
```

== Interesting case

Иногда ренжи могут высчитываться дважды и ломать вам программы. К примеру при конструировании вектора из ренжа, этот ренж будет высчитываться всегда дважды.

== tpoiasi

Легче тут почитать. https://www.fluentcpp.com/2019/02/12/the-terrible-problem-of-incrementing-a-smart-iterator/


== Прочее прочее

Есть много разных прикольных методов работы над ренжами, их можно найти на cppreference

== Ссылки на почитать

Примеры использования от автора ренжей, не все работают в 20-м стандарте https://ericniebler.github.io/range-v3/md_examples.html#example-views

cppreference про ренжи https://en.cppreference.com/w/cpp/ranges

cppreference про алгоритмы, которые можно использовать над ренжами https://en.cppreference.com/w/cpp/algorithm/ranges

Почитать про dangling ренжи https://tristanbrindle.com/posts/rvalue-ranges-and-views