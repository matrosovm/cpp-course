= Семинар №1. Организация разработки программ на С++
:source-highlighter: highlightjs
:revealjs_hash: true
:icons: font
:customcss: https://codepen.io/anstreth/pen/WNvVedL.css
:revealjs_theme: white

== Информация о семинарах

CSC::
- Андрей Серебро, гитхаб: https://github.com/Aspirisha[@Aspirisha]
- Филипп Грабовой, гитхаб: https://github.com/Sviftel[@Sviftel]

[%hardbreaks]
ITMO::
- Дмитрий Заботлин, гитхаб: https://github.com/Arcolight[@Arcolight]

ifdef::backend-revealjs[=== !]

* раз в неделю — занятие
* разбор типичных ошибок из прошлого материала
* выдаются задачи по новому материалу
** решения ревьювятся и оцениваются
* общение в Slack курса

=== дорешки
* 1 неделя на выполнение и сдачу
* сдача задачи в первые 2 дня [без замечаний] — x1.5 баллов
* есть тесты — не покрывают всего
* если задержка с проверкой (и сдача не в последний момент) — на исправление +60 часов

=== контрольные
* каждый 4-ый семинар — контрольная  (3 шт)
* обычно 1 задача с частями на 3, 4, 5 баллов
* решается за занятие — 1,5 часа

== Что вам нужно установить и что нужно знать

- Набор инструментов для компиляции `C++`
  * Компилятор
  * Сборщики `Make` и `CMake`
- Установленный git и аккаунт на https://www.github.com
- Редактор для кода/IDE

=== Сборка
* Компиляция — важно понимать, вникать в ошибки, исправлять их
* Первое время лучше напрямую компилировать из командой строки

* При постоянной работе с `C++` удобны системы сборки. На нашем курсе — `CMake`

=== Чем собирать
* Unix-like ОС, установленный компилятор
** Это предпочтительная конфигурация для прохождения курса
** Компилятор `g\++` или `clang++`, `CMake` и т.д. устанавливаются пакетными менеджерами
** Гуглить `install <tool> on <OS>`, например `install g++ on ubuntu 16.04`

ifdef::backend-revealjs[=== !]

* Windows ОС, установленная Visual Studio + её компилятор (или аналоги)
** Самый простой путь -- установить Visual Studio и пользоваться ей. Она содержит компилятор и CMake
** Путь сложнее -- использовать mingw или cygwin. Погуглите, как это установить

ifdef::backend-revealjs[=== !]

* Сейчас, если нет окружения: онлайн-редактор repl.it
* _Ссылка будет в чате_

=== Семинар #1
* github+git: получить презентацию и код
* IDE: написать решение
* компилятор+CMake: отладить решение
* git: отправить на проверку

=== git
* годный инструмент вне курса
* скорее всего не все будет работать по кнопке
* хорошее руководство (en/ru): https://git-scm.com/book/en/v2[git book]
* хороший курс: https://learngitbranching.js.org/[learngitbranching]

== Цели занятия
- Научиться компилировать простые программы на `C++`;
- Научиться определять и объявлять переменные встроенных типов;
- Поработать с функциями, циклами и условиями;
- Освоить ввод/вывод в консоль и в файл стандартными средствами `C++`.

== Компиляция программ на C++ (для Unix)

Создать исполняемый файл из файла с исходным кодом в `main.cpp`.
Результат: исполняемый файл `a.out`.

[code]
----
$ g++ main.cpp
----

Запустить исполняемый файл.

[code]
----
$ ./a.out
----

ifdef::backend-revealjs[=== !]

Мы будем всегда указывать флаги о дополнительных предупреждениях от компилятора.

[code]
----
$ g++ main.cpp -Wall -Werror
----

== Зачем нужны заголовочные файлы?

Одна из основных целей хедеров -- делить объявления функций между различными единицами компиляции: реализация отдельно от использования

=== В компиляции

Особенность компиляторов `C` и `C++` в том, что каждый `.c/.cpp` файл они компилируют *изолированно друг от друга*,
получая объектные файлы. Затем эти объектные файлы объединяются (линкуются) в итоговый исполняемый файл

ifdef::backend-revealjs[=== !]

Рассмотрим файлы `main.cpp` и `file.cpp`. В `file.cpp` реализованы функции для работы с файлами

.file.cpp
[source,cpp]
----
...

string read(string const& file_name, uint64_t offset) { ... }

...
----

.main.cpp
[source,cpp]
----
int main() {
    cout << read("input.txt", 0) << endl;
    return 0;
}
----


ifdef::backend-revealjs[=== !]

В `main.cpp` используется `read`. Компилятор компилирует `main.cpp` *отдельно*, поэтому он не может посмотреть
в `file.cpp` и проверить, что такая функция там есть и что у неё подходящая сигнатура

ifdef::backend-revealjs[=== !]

Эта проблема решается с помощью использования заголовочных файлов и директив препроцессора `#include`

Создадим заголовочный файл `file.hpp` с таким декларированием:

.file.hpp
[source,cpp]
----
#pragma once

string read(string const& file_name, uint64_t offset);
----

ifdef::backend-revealjs[=== !]

Модифицируем файлы `main.cpp` и `file.cpp`, чтобы они оба включали заголовочный файл в себя:

.file.cpp
[source,cpp]
----
#include "file.hpp"

string read(string const& file_name, uint64_t offset) { ... }

...
----

.main.cpp
[source,cpp]
----
#include "file.hpp"

int main() {
    cout << read("input.txt", 0) << endl;
    return 0;
}
----

ifdef::backend-revealjs[=== !]

Когда компилятор будет обрабатывать эти файлы, он заменит `#include`-ы на содержимое
файлов, на которые они указывают. Например, `main.cpp` будут выглядеть так:

.main.cpp с вставкой
[source,cpp]
----
#pragma once  // на самом деле эта конструкция опустится

string read(string const& file, uint64_t offset);

int main() {
    cout << read("input.txt", 0) << endl;
    return 0;
}
----

ifdef::backend-revealjs[=== !]

Теперь у компилятора есть объявления функции `read` во всех местах, где её используют.
Объявления достаточно, чтобы компилятор смог создать объектный файл.

Если при линковке определение функции так и не будет найдено, то компилятор (линковщик)
выдаст ошибку линковки вида `undefined reference to read(string const&, uint64_t) in main.cpp`

=== Что еще декларируется

.main.cpp с вставкой
[source,cpp]
----
...

string read(string const& file, uint64_t offset);
// или
string read(string const& file, uint32_t offset);
// или совсем нет

int main() {
    cout << read("input.txt", 0) << endl;
    return 0;
}
----

Важно представление литерала `0` в данных

ifdef::backend-revealjs[=== !]

****
У компилятора `g++` есть опция `-E`, позволяющая посмотреть, как будут выглядеть единицы компиляции
после препроцессинга
****

== Задачи

[NOTE]
====
Если вы видите несоответствие между заданием здесь и в коде (в тестах):

1. Сообщите об этом преподавателю
2. Ориентируйтесь на код, если нет жестких противоречий
====

ifdef::backend-revealjs[=== !]

Требования к задачам: 

- Используйте `cin` и `cout` для вывода при выполнении задач, это необходимо для тестов; не используйте другие способы вывода (в том числе `printf` и прочее), если этого не сказано явно

=== Задача №1. Hello World

Напишите и скомпилируйте программу с функцией `say_hello`, выводящей `Hello, world!` в стандартный вывод

Сигнатура функции:

[source,cpp]
----
void say_hello();
----

Объявите функцию в заголовочном файле `say_hello.hpp`, а её тело реализуйте в файле `say_hello.cpp`

=== Задача №2. Fizz Buzz

Напишите функцию, которая выводит на экран числа от `1` до `n`. Вместо чисел, кратных трем, программа должна выводить слово `Fizz`, а вместо чисел, кратных пяти — слово `Buzz`. Если число кратно пятнадцати, то программа должна выводить слово `FizzBuzz`

Сигнатура функции: 

[source,cpp]
----
void fizzbuzz(uint64_t n);
----

ifdef::backend-revealjs[=== !]

Объявите функцию в заголовочном файле `fizzbuzz.hpp`, а её тело реализуйте в файле `fizzbuzz.cpp`

ifdef::backend-revealjs[=== !]

Результат вызова `fizzbuzz(15)`: 
====

[source,cpp]
----
1
2
Fizz
4
Buzz
Fizz
7
8
Fizz
Buzz
11
Fizz
13
14
FizzBuzz
----
====

=== Задача №3

Напишите функцию `compute_fib`, считывающую из `input.txt` целое `N` и возвращающую `N`-ное число Фибоначчи

Число фибоначчи рекомендуется считать нерекурсивно

Сигнатура функции: 

[source,cpp]
----
int64_t compute_fib();
----

ifdef::backend-revealjs[=== !]

Объявите функцию в заголовочном файле `compute_fib.hpp`, а её тело реализуйте в файле `compute_fib.cpp`

