= Контрольная I
:icons: font
:table-caption!:
:cls01ple-caption!:
:source-highlighter: highlightjs
:revealjs_hash: true
:customcss: https://gistcdn.githack.com/fedochet/4ee0f4a2224ecd29a961082a0c63c020/raw/18c107982aba90bb94194c0ac3a8a5ca9bad6782/asciidoc_revealjs_custom_style.css
:revealjs_theme: blood
:stylesheet: main.css

== Задача 1: stl [1 балл]

В задачах есть ограничения на использование некоторых конструкций, алгоритмов и контейнеров,
их можно удалять за какое-то количество количество баллов (к примеру 0.1 балл за ограничение, но может больше, решится в процессе).

=== Подзадача 1: Топовые копатели [0.3 балла]

В Мындексе скоро ревью! Каждый оценивает работу каждого, каждый пишет отзывы на
каждого, в результате кого-то повышают, кому-то поднимают зарплату, а кто-то остаётся на тех же условиях.
В общем интересное время!
В некоторых компаниях (Мындекс одна из них) потраченное на задачу время оценивается в стори понитах (story_point).
А как оценивать работу разработчика, если не по количеству потраченного им времени за эти полгода?

Руководитель твоего подразделения так и посчитал, и попросил тебя, как самого ответственного разработчика(-цу)
найти топ n разработчиков по потраченному времени. Тебе повезло, за тебя уже посчитали, кто сколько проработал.
Но случилось ужасное: один нерадивый разработчик потерял ключ к кладовке. А в ней лежали все `for`-ы, `while`-ы,
`do-while`-ы, `for_each`-и и `accumulate`-ы! Но не только, там ещё лежали и ассоциативные контейнеры.
Вот беда. А ревью-то скоро, часики-то тикают.

==== Задача

Требуется реализовать функцию `GetTopWorkers`.
На вход подаётся вектор имён разработчиков, по которым хочется составить рейтинг, и вектор структур `WorkerInfo`, состоящих из имени работника и того, сколько он проработал (информация о разработчике появляется единожды в массиве `workers_info`).
Тебе надо вернуть список разработчиков в порядке убывания потраченного ими времени, а точнее первых `n` работников в таком списке.

Вектор `workers_info` отсортирован по имени разработчика. Так как работников в Мындексе много, требуется решение за `O(|workers| log(|workers_info|)`.

Среди имён разработчиков (вектор `workers`) могут быть руководители, которые ничего не делают, а только отдыхают. Поэтому и
стори поинтов у них за полгода не накопилось, в массиве `workers_info` их *не* будет. В ответе не должно быть информации по таким 
работникам, а какой смысл.

Нельзя использовать циклы, ассоциативные контейнеры, `accumulate`, `for_each`. Ассемблер тоже использовать нельзя. Короче, используй stl-ные алгоритмы, кроме `for_each` и `accumulate` и будет тебе на ревью десять из десяти.

=== Подзадача 2: Возвращаемся к работе [0.3 балла]

Фуф! Это было потно, но ты справился(-лась), руководитель в восторге, пора возвращаться к работе. Так, смотрим на план спринта,
ага. 

==== Задача

Нужно написать функцию `CollapseSequential`.
Она будет объединять "одинаковые" подряд идущие элементы. Она принимает два итератора источника и один итератор потребитель
(как это обычно и происходит). Также она принимает функцию, которая определяет, какие подряд идущие элементы одинаковые,
а какие - нет. И принимает "объединитель" - функцию, которая собственно объединяет эти самые элементы.

Она должна работать примерно так: находим последовательность "равных" элементов и "объединяем" их с помощью переданной
функции, получили новый элемент. Его уже рассматривать для сравнения с последующими и объединения с ними **не** надо.

То есть если мы захотим объединить в массиве [1,5,4] числа с помощью суммирования,
эквивалентными будем считать числа с одинаковой чётностью, то на первой итерации объединим 1 и 5 (получим 6),
а на второй просто запишем 4, объединять его с 6 не надо.

Ключи от кладовки так и не нашли:( Но у тебя в тумбочке завалялись *один цикл* (в какой хочешь, в такой и превратится)
и один *`accumulate`*. Остальные ограничения продолжают быть актуальными.

=== Подзадача 3: Ревью Ревью Ревью [0.3 балла]

Сидишь ты спокойно, пьёшь с руководителем смузи после тяжёлого рабочего дня,
и вдруг на кофепоинт подскакивает менеджер и резко говорит, что срочно нужно всё переделать.
Он прочитал в книжке, что оценивать людей надо не по потраченному времени, а по потраченному времени на проект!
И в зависимости от того, насколько полезен был проект компании, учитывать его или не очень.

Ну что же, ничего не поделаешь, раз менеджер вычитал в книжке, значит надо делать. В этот раз за тебя никто ничего
не посчитал, у тебя есть список задач: каждая задача описывается её исполнителем, потраченным временем (story_points)
и проектом. Твоя же задача - посчитать, сколько по каждому проекту проработал сотрудник.

==== Задача

Требуется реализовать функцию `GetTopPerformersByProject`. Ей на вход подаётся список задач. Задача описывается
проектом, для которого она делается, исполнителем и затраченным временем. 

Функция должна возвращать вектор структур `ProjectResult`. Один элемент в этом векторе отвечает за один проект.

Структура состоит из названия проекта и списка работников, кто работал над этим проектом (и только из них). 
Для удобства менеджера сотрудников в этом списке надо *отсортировать* в порядке убывания по потраченному времени.

Бедный сотрудник, потерявший ключи от кладовки, уже бьётся в истерике, обошёл весь офис, но найти их никак не может.

Поэтому ограничения из первой задачи сохраняются. Но возможно поможет `CollapseSequential`?

Требуемая асимптотика: `O(nlogn)`, где `n` - количество тасок на входе.

---

== II. Метапрограммирование [1 балл]

На Масленицу подают на стол тарелки с блинами и икрой

[source,cpp]
struct blin {};
struct ikra {};
template<class Sloy1, class... Sloi> struct tarelka {};

Блинов и икры может быть сколько угодно (не менее 1 слоя), но есть физическое ограничение: два слоя икры подряд сделать нельзя (это же получится один толстый слой).

=== Часть 1. Проверка правильности [0.5 балла]

Напишите метафункцию pravilno_v, которая проверяет, правильно ли сформировали стопку блинов и икры (нет двойной икры)

[source,cpp]
template<class Tarelka> constexpr bool pravilno_v = ???;

=== Часть 2. Конструктор тарелки [0.5 балла]

Напишите операцию сложения блинов и икры

[source,cpp]
auto bb = blin{} + blin{};  // tarelka<blin,blin>
auto bi = blin{} + ikra{};  // tarelka<blin,ikra>
auto bii = bi + ikra{};     // невозможно: две икры подряд!
auto ibi = ikra{} + bi;     // tarelka<ikra,blin,ikra>
auto ibi1 = ikra{} + blin{} + ikra{};  // tarelka<ikra,blin,ikra>
auto bibb = bi + bb;        // tarelka<blin,ikra,blin,blin>
auto biibi = bi + ibi;      // невозможно: две икры подряд

Ошибка двойной икры должна быть сделана как SFINAE (не найдётся перегрузка оператора), а не как безусловная ошибка компиляции (например, static_assert внутри). Это нужно для тестирования.

Обратите внимание, что из-за ассоциативности операции сложения операндами и слева и справа могут оказаться и отдельный блин или икра, и тарелки.

---

== Задача 3: макросы [1 балл]

Задача состоит из двух подзадач, каждая из которых оценивается по 0.5 балла

=== Задача 3.1: макрос `FOR_EVERY_NTH_FROM` [0.5 балла]
Напишите макрос `FOR_EVERY_NTH_FROM`, который можно было бы использовать с массивами / стандартными индексируемыми целочисленным неотрицательным индексом контейнерами следующим образом:

ifdef::backend-revealjs[=== !]

Семантика: `FOR_EVERY_NTH_FROM(VARIABLE_NAME, CONTAINER, N, FROM_INDEX)` задает цикл по элементам контейнера `CONTAINER`, начиная с позиции `FROM_INDEX`, пропуская все элементы кроме кратных `N`.
Очередное значение из контейнера должно быть доступно внутри переменной с именем `VARIABLE` и должна быт ьвозможность его изменять (при условии, что это позволяет делать сам контейнер).

[source, cpp]
----
std::vector<size_t> array = {1,2,3,4};

// код ниже должен выполнить тело цикла только для второго (т.к. индексация с нуля) элемента array
// то есть для 3
FOR_EVERY_NTH_FROM(value, array, 3, 0) {
  value += 2;
  std::cout << ++value << std::endl;
}

// здесь array == {1,2,5,4}
----

ifdef::backend-revealjs[=== !]
Определите также вспомогательные макросы `FOR_EVERY_NTH` и `FOR_EVERY`, первый задает дефолтное значение стартового индекса `FROM_INDEX` равным 0, а второй помимо этого задает значение `N` равным 1.

=== Задача 3.2: макрос `FOR_I_IN_RANGE` [0.5 балла]

Напишите макрос `FOR_I_IN_RANGE`, который можно было бы вызывать от двух, трех или четырхе аргументов.

Макрос, вызванный от двух аргументов имеет вид `FOR_I_IN_RANGE(value, N)`, где переменная `value` пробегает значения от 0 до N. Обратите внимание, что тип `value` должен совпадать с типом `N` без учёта cv-квалификаторов и ссылочности.

Добейтесь того, чтобы попытка инстанцировать макрос с нецелочисленным `N` приводила к ошибке компиляции.

[source, cpp]
----
// выведет 0, 1, 2
FOR_I_IN_RANGE(value, 3) {
  std::cout << value << " ";
}
----

ifdef::backend-revealjs[=== !]

Макрос, вызванный от трёх аргументов имеет вид `FOR_I_IN_RANGE(value, FROM, TO)`. Как и в случае с макросом от двух аргументов, тип `value` задается типом `FROM` и `TO` (все эти типы должны совпадать без учёта cv-квалификаторов и ссылочности).
Обеспечьте compile-time проверку корректности типов, а также что FROM/TO целочисленные.

[source, cpp]
----
// выведет 1, 2, 3, 4; тип value должен оказаться unsigned long
FOR_I_IN_RANGE(value, 1ul, 2ul + 3ul) {
  std::cout << value << " ";
}
----

ifdef::backend-revealjs[=== !]
Наконец, макрос, вызванный от четырёх аргументов имеет вид `FOR_I_IN_RANGE(value, FROM, TO, STEP)`. Требования к типам `FROM`, `TO`, `STEP` такие же, как в случае макроса от трёх аргументов.

[source, cpp]
----
// выведет 1, 3
FOR_I_IN_RANGE(value, 1, 5, 2) {
  std::cout << value << " ";
}
----
