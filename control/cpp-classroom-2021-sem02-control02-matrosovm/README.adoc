= Контрольная II
:icons: font
:table-caption!:
:cls01ple-caption!:
:source-highlighter: highlightjs
:revealjs_hash: true
:customcss: https://gistcdn.githack.com/fedochet/4ee0f4a2224ecd29a961082a0c63c020/raw/18c107982aba90bb94194c0ac3a8a5ca9bad6782/asciidoc_revealjs_custom_style.css
:revealjs_theme: blood
:stylesheet: main.css

== Задача 1: Многопоточность [1.5 балла]

Нам предстоит доработать два класса: `ExecutionQueue` и `Buffer`.

С каждым объектом типа Buffer можно связать очередь исполнения (`ExecutionQueue`) посредством вызова метода `Buffer::move_to_execution_queue`.
Это должно быть можно делать многократно и из произвольных потоков.

Класс `Buffer` имеет метод `post`, добавляющий в буффер задачу. Задача в данном контексте это `std::function<void()>`.
Как только в ассоциированной с буффером `ExecutionQueue` (если она есть!) не оказывается исполняющихся задач, *посланных этим буфером*, буффер отправляет задачу на исполнение в `ExecutionQueue`.
Таким образом, в каждый момент времени в `ExecutionQueue` имеется не более *одной* задачи, посланной определенным буфером (но может быть много задач от разных буферов).

Если число задач в `Buffer`, ожидающих посылки в `ExecutionQueue`, превышает допустимый максимальный размер очереди, передаваемый как std::optional<size_t> буфферу в конструкторе, то самая старая задача дропается.

`ExecutionQueue` в своем конструкторе заводит поток, в котором синхронно исполняет переданные на вход задачи.

Все публичные методы `Buffer` и `ExecutionQuque` должно быть можно вызывать из разных потоков.

Код уже написан, и даже *обычно* проходит тесты (sic! это вообще говоря может быть делом случая! :)), однако не является потокобезопасным. Ваша задача - сделать его таковым!

Обратите внимание, вы *можете* и даже *должны* добавлять новые поля (примитивы синхронизации) к классам при решении задачи.

image:https://i.ibb.co/mFMHzCw/buffer-worker.png[]

== Задача 2: Динамические библиотеки [1.5 балла]

В этой задачке мы хотим написать две динамические библиотеки для чтения-записи структуры `PhoneBook`. Структурка очень простая,
содержит внутри себя всего лишь одну мапу из имени в телефон человека.

Каждая из двух динамических библиотек должна реализовывать интерфейс,
описанный в `extern "C"` части заголовочного файла `phonebook.hpp`.

[source,cpp]
----
void read_phonebook(PhoneBook* pb, std::istream &in);
void write_phonebook(const PhoneBook* pb, std::ostream &out);
----

Одна библиотека должна позволять сериализовывать и десериализовывать структуру PhoneBook, используя библиотеку `json`, вторая - используя `protobuf`. Для удобства прото файлик `phonebook.proto` лежит рядом.
Смоук тест ко второй задаче *не линкуется* с динамическими библиотеками, которые вы пишете, а загружает их динамически.

Обратите внимание на имена таргетов своих библиотек, если они будут отличаться от тех, что предполагаются в тесте, поправьте их в соответствии с тестом (для windows укажите правильные имена в тесте).
В целом, тест может оказаться не до конца работоспособным на винде, be warned.

Свой код поместите в json_parser.cpp и protobuf_parser.cpp соответственно. Также приложите какой-либо скрипт сборки для ваших динамических библиотек - его адекватность также будет оцениваться. Можно использовать cmake (например дописать в имеющийся CMakeLists.txt), nmake, make, просто batch/bash файл с инструкциями по сборке либ.
